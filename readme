### 在 Docker 中使用二级域名部署两个 Web 网站的详细操作步骤

尊敬的同事，感谢您对该部署方案的进一步咨询。以下是从环境准备开始的详细操作步骤。该方案基于 Docker Compose 和 Nginx 反向代理，实现两个 Web 网站（例如，`site1.example.com` 和 `site2.example.com`）通过不同的二级域名访问各自的镜像服务，同时共享宿主机的 80 端口。每个步骤均包含具体命令、文件内容和注意事项，以确保可操作性和可追溯性。

假设您使用 Linux 或 macOS 系统作为宿主机；Windows 用户可通过 WSL2 或 Docker Desktop 类似执行。替换示例域名（`site1.example.com` 和 `site2.example.com`）为您的实际二级域名，并确保 DNS 已配置解析到服务器 IP（本地测试时使用 `/etc/hosts` 文件模拟）。

#### 步骤 1: 准备 Docker 环境
安装并验证 Docker 和 Docker Compose，确保系统满足最低版本要求（Docker ≥ 20.10，Docker Compose ≥ 2.0）。

- **安装 Docker**（如果未安装）：
  - Ubuntu/Debian：执行 `sudo apt update && sudo apt install docker.io -y`，然后 `sudo systemctl start docker && sudo systemctl enable docker`。
  - macOS：下载并安装 Docker Desktop 从 [docker.com](https://www.docker.com/products/docker-desktop/)。
  - 验证：运行 `docker --version` 和 `sudo usermod -aG docker $USER`（添加用户到 docker 组，重启终端）。

- **安装 Docker Compose**（如果未安装）：
  - 下载：`sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose`。
  - 授权：`sudo chmod +x /usr/local/bin/docker-compose`。
  - 验证：运行 `docker-compose --version`。

- **注意事项**：确保防火墙允许 80 端口（例如，`sudo ufw allow 80`）。重启终端以应用组变更。

#### 步骤 2: 创建项目目录和基本文件结构
建立专用目录以组织配置文件和代码。

- **创建目录**：
  ```
  mkdir multi-site-docker
  cd multi-site-docker
  ```

- **创建子目录和文件**：
  - Nginx 配置目录：`mkdir nginx`。
  - Site1 静态内容目录（示例）：`mkdir site1` 并在其中创建 `index.html` 文件：
    ```
    echo "<h1>Welcome to Site1</h1>" > site1/index.html
    ```
  - Site2 应用目录（Node.js 示例）：`mkdir site2` 并创建以下文件：
    - `package.json`：
      ```
      {
        "name": "site2",
        "version": "1.0.0",
        "main": "app.js",
        "dependencies": {
          "express": "^4.18.0"
        }
      }
      ```
    - `app.js`：
      ```
      const express = require('express');
      const app = express();
      app.get('/', (req, res) => res.send('<h1>Hello from Site2!</h1>'));
      app.listen(3000, () => console.log('Site2 running on port 3000'));
      ```
    - `Dockerfile`：
      ```
      FROM node:18-alpine
      WORKDIR /app
      COPY package*.json ./
      RUN npm install
      COPY app.js ./
      EXPOSE 3000
      CMD ["node", "app.js"]
      ```

- **注意事项**：对于生产环境，将您的实际镜像或代码替换这些示例文件。确保目录权限正确（`chmod -R 755 .`）。

#### 步骤 3: 配置 Docker Compose 文件
定义服务、网络和卷映射。

- **创建 `docker-compose.yml`**：
  使用文本编辑器（如 `nano docker-compose.yml`）添加以下内容：
  ```
  version: '3.8'

  services:
    nginx:
      image: nginx:alpine
      ports:
        - "80:80"  # 统一监听宿主机 80 端口
      volumes:
        - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      depends_on:
        - site1
        - site2
      networks:
        - web-net

    site1:
      image: nginx:alpine  # 替换为您的 site1 镜像
      volumes:
        - ./site1:/usr/share/nginx/html:ro  # 挂载静态内容
      networks:
        - web-net
      # 无 ports 映射，仅内部访问

    site2:
      build: ./site2  # 使用本地 Dockerfile 构建 site2
      networks:
        - web-net
      # 无 ports 映射

  networks:
    web-net:
      driver: bridge
  ```

- **注意事项**：`depends_on` 确保启动顺序；网络 `web-net` 启用容器间通信（通过服务名如 `site1` 访问）。

#### 步骤 4: 配置 Nginx 反向代理
定义域名路由规则。

- **创建 `nginx/nginx.conf`**：
  使用 `nano nginx/nginx.conf` 添加以下内容：
  ```
  events {
      worker_connections 1024;
  }

  http {
      upstream site1_backend {
          server site1:80;  # 通过服务名访问 site1 内部端口
      }
      upstream site2_backend {
          server site2:3000;  # 访问 site2 内部端口
      }

      # Site1 服务器块
      server {
          listen 80;
          server_name site1.example.com;  # 替换为您的域名

          location / {
              proxy_pass http://site1_backend;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          }
      }

      # Site2 服务器块
      server {
          listen 80;
          server_name site2.example.com;  # 替换为您的域名

          location / {
              proxy_pass http://site2_backend;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          }
      }

      # 默认服务器块（处理未匹配请求）
      server {
          listen 80 default_server;
          return 404;
      }
  }
  ```

- **注意事项**：替换 `server_name` 为实际域名。测试配置语法：后续步骤中运行 `docker-compose exec nginx nginx -t`。

#### 步骤 5: 启动和验证服务
部署容器并进行初步测试。

- **构建并启动服务**：
  ```
  docker-compose up -d --build
  ```
  - `-d` 表示后台运行；`--build` 构建 site2 镜像。

- **检查服务状态**：
  ```
  docker-compose ps
  ```
  预期输出：所有服务状态为 "Up"。

- **查看日志**：
  ```
  docker-compose logs nginx
  docker-compose logs site1
  docker-compose logs site2
  ```
  确认无错误（如端口绑定失败）。

- **本地测试**（如果无真实 DNS）：
  - 编辑 `/etc/hosts`（需 sudo）：添加 `127.0.0.1 site1.example.com site2.example.com`。
  - 浏览器访问 `http://site1.example.com`（应显示 Site1 内容）和 `http://site2.example.com`（显示 Site2 内容）。

- **生产测试**：使用真实域名访问，确保 DNS 解析正确。

#### 步骤 6: 故障排除和优化
处理常见问题并增强配置。

- **常见故障**：
  - **端口冲突**：检查 `sudo netstat -tuln | grep 80` 并停止占用进程。
  - **Nginx 配置错误**：运行 `docker-compose exec nginx nginx -t` 验证语法。
  - **容器间通信失败**：确认网络 `docker network ls` 和 `docker network inspect multi-site-docker_web-net`。
  - **权限问题**：使用 `docker-compose down` 停止，重启后重新 `up`。

- **优化建议**：
  - **HTTPS 支持**：添加 Certbot 容器生成证书，并在 `nginx.conf` 中配置 `listen 443 ssl;` 和证书卷。示例：扩展 Compose 以包含 `ports: - "443:443"`。
  - **重载配置**：修改 `nginx.conf` 后，运行 `docker-compose exec nginx nginx -s reload`。
  - **扩展站点**：添加新服务到 Compose，并在 `nginx.conf` 中新增 `upstream` 和 `server` 块，然后 `docker-compose up -d`。
  - **清理**：停止服务 `docker-compose down -v`（删除卷）。

此流程确保部署的可靠性和可维护性。如果在任何步骤中遇到特定错误，或需针对特定镜像（如 PHP 或 Python 应用）调整配置，请提供更多细节，我将协助优化。